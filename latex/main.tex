% SETUP DOCUMENTO %
\documentclass[onecolumn]{article}
\usepackage[italian]{babel}

\usepackage{tgschola}
\linespread{1.25}
\usepackage[fontsize=12pt]{scrextend}
\usepackage[a4paper,top=2.5cm,bottom=2.5cm,left=3cm,right=3cm,marginparwidth=1.75cm,footskip=1.5cm,heightrounded]{geometry}

\usepackage{xcolor}
\usepackage{amsmath}
\usepackage[bottom]{footmisc}

% IMMAGINI %
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{ {./images/} }

% TABELLE %
\usepackage{adjustbox}
\usepackage{booktabs}

% STILE LINK ESTERNI %
\definecolor{linkColor}{RGB}{2,11,120}
\usepackage[colorlinks=true, allcolors=linkColor]{hyperref}
\newcommand\anchor[2]{%
  \href{#2}{#1}\footnote{\url{#2}}%
}

% STILE BLOCCHI DI CODICE %
\definecolor{bgTitleRed}{RGB}{85,45,50}
\usepackage[T1]{fontenc}
\usepackage[ttdefault=true]{AnonymousPro}
\usepackage{listings}
\usepackage{minted}
\usepackage{tcolorbox}
\tcbuselibrary{listings, breakable, minted, skins}
\tcbset{listing engine=minted}

\newtcblisting{bashCode}[2][]{
    breakable,
    listing only, #1 ,title=#2,
    minted language=bash,
    minted style=vs,
    coltitle=white,
    colbacktitle=bgTitleRed,
    toptitle=3mm, bottomtitle=2.5mm,
    top=2mm, bottom=3mm,
    fonttitle=\ttfamily,
    enhanced, frame hidden, 
    minted options={fontfamily=AnonymousPro, 
    tabsize=4, breaklines, autogobble, linenos=false}}

\setminted[python]{fontfamily=AnonymousPro, fontsize=\footnotesize, breaksymbol=.}

% INTESTAZIONE %
\title{Relazione Laboratorio Algoritmi\\\textit{Esercizio B}}
\author{Alberto Del Buono Paolini}
\date{Ottobre 2023}

\begin{document}
\begin{onecolumn}
	\vspace*{-6em}
	{\let\newpage\relax\maketitle}
	\vspace*{-2em}
	\tableofcontents
\end{onecolumn}
\vspace{1cm}
\pagebreak

% CONTENUTO %
\section{Descrizione del problema}

\subsection{Introduzione}
Questa relazione vuole analizzare e commentare il calcolo delle statistiche d'ordine dinamiche \textit{os-select} e \textit{os-rank}, mettendo a confronto le seguenti strutture dati: 
\begin{enumerate}
	\setlength\itemsep{-0.25em}
	\item Lista ordinata collegata con puntatori
	\item Albero binario di ricerca senza attributo \textit{size}
	\item Albero rosso-nero con attributo \textit{size}
\end{enumerate}

L'obiettivo è valutare le prestazioni e le caratteristiche di ciascuna implementazione attraverso test ed esperimenti pratici, confrontandole con le evidenze teoriche descritte in questo capitolo.

\subsection{Caratteristiche teoriche}

Per prima cosa dobbiamo descrivere la natura di queste tre strutture dati e delle statistiche d'ordine dinamiche che andremo ad analizzare. Esamineremo quindi nei vari casi le complessità computazionali di:

\begin{enumerate}
	\setlength\itemsep{-0.25em}
	\item \textit{os-select(k)}: è un'operazione che trova l'elemento con un rango specifico $k$ in un insieme di dati, cioè restituisce il $k$-esimo elemento più piccolo dell'insieme di dati.
	\item \textit{os-rank(x)}: è un'operazione che calcola il rango di un elemento specifico $x$ all'interno di un insieme di dati, dove il rango di un elemento è il numero di elementi nell'insieme che sono inferiori o uguali a $x$.
\end{enumerate}

\subsubsection{Lista collegata ordinata}

Questa è una struttura composta da nodi che hanno attributi \textit{value} (il valore del dato contenuto nel nodo) e \textit{next} (un puntatore al nodo successivo della lista oppure vuoto). Per attraversare completamente una lista collegata con puntatori bisogna quindi partire dal primo nodo (chiamato solitamente \textit{head}) e spostarsi sui nodi successivi tramite il puntatore \textit{next}, fino a che non è vuoto, a significare la fine della lista. Inoltre è una struttura ordinata: ogni nodo viene inserito nella lista in base al valore del suo dato (con ordine ascendente o discendente). Supponiamo di essere nel caso di ordine ascendente, come mostrato in \hyperref[fig:lista]{figura 1}.

\begin{figure}
	\includegraphics[width=\linewidth]{lista.png}
	\caption{Lista collegata con puntatori}
	\label{fig:lista}
\end{figure}

\textbf{os-select}: questa operazione richiede di scorrere la lista dall'inizio, contando gli elementi fino a raggiungere il $k$-esimo. Questo significa che il tempo necessario per trovare questo elemento cresce linearmente con $k$ e, nel caso peggiore, bisognerà scorrere tutta la lista lunga $n$. La complessità di os-select è quindi $O(k)$ e $\Theta(n)$ nel caso peggiore. \vspace{0.5em}

\textbf{os-rank}: Per determinare il rango di un elemento x bisogna scorrere la lista contando quante chiavi sono inferiori a $x$, perciò le complessità sono uguali a os-select. La lista collegata ordinata non è molto efficiente per il calcolo delle due statistiche d'ordine, specialmente quando si cerca un $k$ o un $x$ grande. 

\subsubsection{Albero binario di ricerca}

Un albero binario di ricerca è una struttura dati gerarchica composta da nodi collegati tra loro. Ogni nodo ha attributi per al massimo due figli, uno a sinistra (\textit{left}) e uno a destra (\textit{right}), e un valore (\textit{value}) che soddisfi le seguenti proprietà:

\begin{enumerate}
	\setlength\itemsep{-0.25em}
	\item I valori nei nodi del sottoalbero sinistro sono inferiori o uguali al valore nel nodo padre.
	\item I valori nei nodi del sottoalbero destro sono superiori al valore nel nodo padre.
\end{enumerate}

Quindi per qualsiasi nodo nell'ABR (illustrato in \hyperref[fig:alberi]{figura 2a}), tutti i nodi nei sottoalberi a sinistra contengono valori inferiori o uguali, e tutti i nodi nei sottoalberi a destra contengono valori superiori; questo aiuta la complessità del calcolo delle statistiche d'ordine. \vspace{1em}

\textbf{os-select}: Questo metodo attraversa un singolo percorso nell'albero per trovare il $k$-esimo elemento e la complessità è $O(h)$, dove $h$ è l'altezza dell'albero. Il tempo di esecuzione dipende dall'altezza dell'albero e dalla struttura specifica dell'albero. Se l'albero è bilanciato, l'altezza è $\Theta(\log n)$, garantendo una complessità di $O(\log n)$ nel caso peggiore. \vspace{0.5em}

\textbf{os-rank}: anche os-rank richiede un percorso nell'albero fino a un elemento specifico $x$ e ha una complessità temporale di $O(h)$. Sarebbe necessaria la costante riequilibratura dell'albero per mantenere la complessità $O(\log n)$. Tuttavia, se l'albero è sbilanciato con un unico ramo, la complessità può arrivare fino a $\Theta(n)$, ugualmente ad os-select.

\begin{figure}
	\centering
	\subfloat[Albero binario di ricerca]{{\includegraphics[width=\linewidth/2-1.5em]{abr} }}
	\qquad
	\subfloat[Albero rosso-nero aumentato]{{\includegraphics[width=\linewidth/2-1.5em]{arn} }}
	\caption{Illustrazioni alberi}
	\label{fig:alberi}
\end{figure}

\subsubsection{Albero rosso-nero aumentato con attributo \textit{size}}

Gli alberi rosso-neri aumentati sono una variante dei tradizionali alberi rosso-neri. Le proprietà di un albero rosso-nero sono estese da quelle di un albero binario di ricerca con la seguente: ogni nodo in un ARN è etichettato come \textit{rosso} o \textit{nero} nell'attributo \textit{color}, seguendo le seguenti regole per garantire che l'albero sia bilanciato:

\begin{enumerate}
	\setlength\itemsep{-0.25em}
	\item Un nodo è o rosso o nero.
	\item La radice dell'albero è nera.
	\item Non possono esistere due nodi rossi consecutivi lungo qualsiasi cammino dall'alto verso il basso.
\end{enumerate}

Gli ARN aumentati (in \hyperref[fig:alberi]{figura 2b}) includono una modifica aggiuntiva: l'attributo \textit{size} in ciascun nodo dell'albero. Questo attributo tiene traccia del numero di nodi nel sottoalbero con radice in quel nodo (include anche il nodo stesso) e velocizza in media il calcolo del rango di un elemento all'interno dell'albero. \vspace{1em}

\textbf{os-select}: l'operazione di os-select è molto efficiente grazie all'attributo \textit{size}, possiamo trovare il $k$-esimo elemento sempre in $O(h)$ e $\Theta(\log n)$ nel caso peggiore. \vspace{0.5em}

\textbf{os-rank}: Anche l'operazione di os-rank ha una complessità di $O(h)$ e di $\Theta(\log n)$ nel caso peggiore. \vspace{1em}

In generale, l'implementazione con l'albero rosso-nero aumentato con l'attributo \textit{size} eccelle nel calcolo di entrambe le statistiche d'ordine, offrendo prestazioni notevolmente migliori rispetto agli ABR non bilanciati, essendo bilanciati ad ogni nuovo inserimento. Le complessità per le varie strutture sono riassunte in \hyperref[tab:complessita]{tabella 1}.

\begin{table}[t]
	\centering
	\begin{tabular}{|c|c|c|c|}
		\hline
		                   & Lista ordinata & \hspace*{2em}ABR\hspace*{2em} & ARN aumentato \\
		\hline
		\textbf{os-select} & $O(k)$         & $O(\log n)$                   & $O(\log n)$   \\
		\hline
		\textbf{os-rank}   & $O(n)$         & $O(\log n)$                   & $O(\log n)$   \\
		\hline
	\end{tabular}
	\caption{Complessità delle statistiche d'ordine}
	\label{tab:complessita}
\end{table}

\section{Descrizione degli esperimenti}
\subsection{Piattaforma di esecuzione}

Per sviluppare il codice ed eseguire tutti i test, ottenendo le tabelle e i grafici riportati in questo documento, è stata utilizzata un'istanza di \anchor{Gitpod}{https://www.gitpod.io/} con le seguenti specifiche:
\begin{bashCode}{Output neofetch}
	OS: Ubuntu 22.04.3 LTS x86_64 
	Host: Google Compute Engine 
	Kernel: 6.1.54-060154-generic 
	CPU: AMD EPYC 7B13 (16 cores) @ 2.449GHz 
	Memory: 30099MiB / 64297MiB
\end{bashCode}

\subsection{Dimensione e popolazione delle strutture}

E' fondamentale eseguire i test su diverse dimensioni delle strutture dati per valutare come le prestazioni variano con l'aumento del numero di elementi. Andremo a testare le prestazioni su insiemi di dati di dimensioni:
\begin{enumerate}
	\setlength\itemsep{-0.25em}
	\item 10-1000
	\item 1000-10000
\end{enumerate}

Nel primo caso stiamo considerando strutture dati con dimensioni ridotte, nel secondo caso invece le dimensioni sono abbastanza elevate da esemplificare anche strutture più grandi. Oltretutto per il primo intervallo i test verranno eseguiti su ogni dimensione tra 10 e 1000 con step 10 (10, 20, 30, ...). Per il secondo intervallo le dimensioni sono scelte in maniera più sparsa a causa del maggior tempo di esecuzione (con step di 500). \vspace{1em}

Ogni struttura dati, prima dei test sulle statistiche d'ordine, viene popolata in modo casuale con:
\begin{enumerate}
	\setlength\itemsep{-0.25em}
	\item \textit{Valori interi} compresi tra 1 e la dimensione della struttura (oppure 1000 se questa è inferiore)
	\item \textit{Valori float} compresi tra 1 e la dimensione della struttura
\end{enumerate}

\subsection{Strategia di iterazione e misurazione}

Per ogni struttura dati e per ogni statistica d'ordine dinamica verranno eseguiti i test un certo numero di iterazioni (consideriamo 250 come numero sufficiente) per ogni dimensione specificata. Per ognuna di queste iterazioni, le operazioni saranno svolte in modo casuale sugli elementi della struttura dati, andando a simulare uno scenario realistico di utilizzo delle statistiche d'ordine. 

Raccoglieremo poi la mediana e deviazione standard dei tempi di esecuzione per ogni dimensione, producendo i rispettivi grafici. Questo metodo riduce l'impatto di variazioni casuali e fornisce risultati più stabili, andando comunque a visualizzare tutto l'intervallo di confidenza delle operazioni compiute.

Per ogni misurazione saranno proposti due grafici, uno che usa il tempo effettivo di esecuzione delle istruzioni e un altro che utilizza un tempo relativo alla dimensione dell'insieme di dati (utile per visualizzare la complessità computazionale nei vari casi), calcolati come segue:
\begin{enumerate}
	\setlength\itemsep{-0.25em}
	\item \textit{Tempo effettivo}: \verb|end_time - start_time|
	\item \textit{Tempo relativo}: \verb|(end_time - start_time) / size|
\end{enumerate}

Tutte le misurazioni dei tempi sono effettuate usando la libreria \verb|timeit| che ci fornisce risultati di esecuzione accurati.

\newpage
\section{Documentazione del codice}

La struttura delle classi è osservabile nel diagramma UML in \hyperref[fig:classi]{figura 3}; segue anche una breve descrizione di ogni attributo e metodo implementato per le tre strutture dati. Tutti gli attributi e i metodi sono corredati di annotazioni di tipo nel codice (validate con \verb|mypy|). La cronologia completa dello sviluppo è disponibile su una repository Github pubblica reperibile tramite \anchor{questo link}{https://github.com/albbus-stack/lab-alg}. 

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{classi.png}
	\caption{Diagramma UML delle classi}
	\label{fig:classi}
\end{figure}

\subsection{Lista collegata ordinata}
\texttt{\textbf{LinkedListNode}}
\begin{itemize}
	\setlength\itemsep{0em}
	\item \verb|value|: il valore memorizzato nel nodo
	\item \verb|next|: il riferimento al nodo successivo
\end{itemize}

{\setlength{\parindent}{0em} \texttt{\textbf{OrderedLinkedList}}}
\begin{itemize}
	\setlength\itemsep{0em}
	\item \verb|head|: il riferimento al primo nodo nella lista (di tipo \texttt{LinkedListNode})
	\item \verb|insert(value)|: inserisce un nuovo nodo nella lista con il valore specificato 
	\item \verb|os_select(k)|: restituisce il valore dell'elemento con rango $k$ nella lista
	\item \verb|os_rank(value)|: restituisce il rango dell'elemento con valore specificato nella lista
\end{itemize}

\subsection{Albero binario di ricerca}
\texttt{\textbf{TreeNode}}
\begin{itemize}
	\setlength\itemsep{0em}
	\item \verb|value|: il valore memorizzato nel nodo
	\item \verb|left|: il riferimento al figlio sinistro
	\item \verb|right|: il riferimento al figlio destro
\end{itemize}

{\setlength{\parindent}{0em} \texttt{\textbf{BinarySearchTree}}}
\begin{itemize}
	\setlength\itemsep{0em}
	\item \verb|root|: il riferimento alla radice dell'albero (di tipo \texttt{TreeNode})
	\item \verb|insert(value)|: inserisce un nuovo nodo con il valore specificato nell'ABR, usa il metodo privato ricorsivo \verb|_insert_recursive(root, value)| a partire dalla radice.
	\item \verb|_tree_size(root)|: calcola la dimensione del sottoalbero radicato in un nodo specifico ricorsivamente
	\item \verb|os_select(k)|: restituisce il valore dell'elemento con rango $k$ usando il metodo privato ricorsivo \verb|_os_select_recursive(root, k)| che naviga l'albero a seconda della dimensione dei sottoalberi 
	\item \verb|os_rank(value)|: restituisce il rango dell'elemento con valore specificato  usando il metodo privato \verb|_os_rank_recursive(root, value)| che cerca ricorsivamente \textit{value} nell'albero e restituisce la dimensione del suo sottoalbero
\end{itemize}

\subsection{Albero rosso-nero aumentato con attributo \textit{size}}
\texttt{\textbf{RedBlackTreeNode}}
\begin{itemize}
	\setlength\itemsep{0em}
	\item \verb|color|: il colore del nodo (di tipo \texttt{Color}: \texttt{RED} o \texttt{BLACK})
	\item \verb|size|: il numero di nodi nel sottoalbero radicato in questo nodo
	\item \verb|left|: il riferimento al figlio sinistro
	\item \verb|right|: il riferimento al figlio destro
	\item \verb|value|: il valore memorizzato nel nodo (ereditato dalla classe \texttt{TreeNode})
\end{itemize}

\newpage
{\setlength{\parindent}{0em} \texttt{\textbf{AugmentedRedBlackTree}}}
\begin{itemize}
	\setlength\itemsep{0em}
	\item \verb|root|: il riferimento alla radice dell'ARN aumentato (di tipo \texttt{RedBlackTreeNode})
	\item \verb|insert(value)|: inserisce un nuovo nodo con un certo valore nell'albero rosso-nero aumentato; usa il metodo ricorsivo \texttt{\_insert\_recursive(root, value)} che, dopo aver inserito il valore, bilancia l'albero
	\item \verb|os_select(k)|: restituisce il valore dell'elemento con rango $k$ nell'albero rosso-nero aumentato, la sua implementazione è uguale a quella dell'albero binario di ricerca, a parte per il metodo \texttt{\_size(node)}
	\item \verb|os_rank(value)|: restituisce il rango dell'elemento col valore specificato e anche la sua implementazione è la stessa degli ABR, a parte per il metodo \texttt{\_size(node)}
	\item \verb|_size(node)|: ritorna l'attributo \textit{size} oppure 0 se il nodo è \texttt{None}
	\item \verb|_is_red(node)|: ritorna \texttt{True} se il nodo ha colore rosso oppure \texttt{False} se il nodo è nero o \texttt{None}
	\item \verb|_rotate_left(node)|: esegue una rotazione sinistra del sottoalbero rosso-nero con radice nel nodo
	\item \verb|_rotate_rigth(node)|: esegue una rotazione destra del sottoalbero rosso-nero con radice nel nodo
	\item \verb|_flip_colors(node)|: inverte i colori di un nodo e dei suoi due figli nell'ARN
\end{itemize}

\subsection{Classi statiche \texttt{Tester} e \texttt{Utils}}

Queste classi contengono tutti metodi statici che sono stati raggruppati semanticamente in esse.
\vspace{0.75em}
\newline
\texttt{\textbf{Tester}}
\begin{itemize}
	\setlength\itemsep{0em}
	\item \verb|test_ordered_list(sizes, iterations)|: esegue test e raccolta dati per la lista collegata ordinata
	\item \verb|test_bst(sizes, iterations)|: esegue test e raccolta dati per l'albero binario di ricerca
	\item \verb|test_augmented_rbt(sizes, iterations)|: esegue test e raccolta dati per l'albero rosso-nero aumentato con attributo \textit{size}
\end{itemize}

\newpage
{\setlength{\parindent}{0em} \texttt{\textbf{Utils}}}
\begin{itemize}
	\setlength\itemsep{0em}
	\item \verb|data_and_table(sizes, times, caption, plot_filename)|: genera e restituisce mediane e deviazioni standard insieme alla stringa in \LaTeX\ della corrispettiva tabella per le dimensioni e i tempi di esecuzione specificati
	\item \verb|plot(sizes, medians, dev_std, label)|: crea un grafico con mediane e deviazioni standard
	\item \verb|clear_plot()|: cancella il grafico corrente
	\item \verb|save_plot(plot_filename, title)|: salva il grafico corrente in un \texttt{.png} con un titolo specificato
	\item \verb|write_to_latex_file(filename, lines)|: scrive le linee in un file \TeX\ con il nome specificato
\end{itemize}

\section{Analisi dei risultati sperimentali}

In questa sezione, condurremo un'analisi completa dei risultati sperimentali. Discuteremo le discrepanze tra le prestazioni attese e quelle effettivamente osservate, se presenti, e offriremo interpretazioni basate sui dati raccolti. 

Riferimenti alle tabelle: \ref{OS-Select in una lista ordinata}, \ref{OS-Rank in una lista ordinata}, \ref{OS-Select in un ABR}, \ref{OS-Rank in un ABR}, \ref{OS-Select in un albero RN aumentato}, \ref{OS-Rank in un albero RN aumentato}.

\subsection{os-select}

\subsubsection{Dimensioni ridotte}
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth-5em]{os-select.png}
	\caption{Tempi di Os-select}
	\label{fig:os-select}
\end{figure}
\subsubsection{Dimensioni elevate}

\subsection{os-rank}
\subsubsection{Dimensioni ridotte}

\begin{figure}[H]
    \centering
	\includegraphics[width=\linewidth]{os-rank.png}
	\caption{Tempi di Os-rank}
	\label{fig:os-rank}
\end{figure}

\subsubsection{Dimensioni elevate}

\section{Conclusioni}

Concluderemo la relazione con un riepilogo delle scoperte chiave e delle implicazioni dei risultati sperimentali. Discuteremo anche eventuali sviluppi futuri e possibili miglioramenti.

\newpage

\twocolumn
\section{Tabelle}
\vspace{2.75em}
\input{tabelle-lista-ordinata}
\input{tabelle-abr}
\input{tabelle-rn-aumentato}

\end{document}